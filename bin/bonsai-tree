#!/usr/bin/env bash
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
##@Version       : 202601061012-git
# @Author        : Jason Hempstead
# @Contact       : jason@casjaysdev.pro
# @License       : WTFPL
# @ReadME        : bonsai-tree --help
# @Copyright     : Copyright: (c) 2021 Jason Hempstead, CasjaysDev
# @Created       : Tuesday, Mar 23, 2021 07:41 EDT
# @File          : bonsai-tree
# @Description   : bonsai.sh is a static and live bonsai tree generator, written in bash.
# @Changelog     : Refactored for self-contained operation
# @TODO          :
# @Other         : Author: John Allbritten: theSynAck.com
# @Resource      : https://gitlab.com/jallbrit/bonsai.sh.git
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Script variables
PROG="bonsai-tree"
VERSION="202601061012-git"
USER="${SUDO_USER:-${USER}}"
HOME="${USER_HOME:-${HOME}}"
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Environment Detection
__get_os() {
  case "$(uname -s)" in
    Linux*) echo "linux" ;;
    Darwin*) echo "mac" ;;
    *BSD*) echo "bsd" ;;
    MINGW*|MSYS*|CYGWIN*) echo "windows" ;;
    *) echo "unknown" ;;
  esac
}

__is_remote() {
  [ -n "${SSH_CLIENT:-}" ] || [ -n "${SSH_TTY:-}" ] || [ -n "${SSH_CONNECTION:-}" ]
}

__has_display() {
  [ -n "${DISPLAY:-}" ] || [ -n "${WAYLAND_DISPLAY:-}" ]
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Core helper functions
__cmd_exists() { command -v "$1" >/dev/null 2>&1; }

__is_running() {
  local proc="$1"
  case "$(__get_os)" in
    mac) pgrep -x "$proc" >/dev/null 2>&1 ;;
    windows) tasklist 2>/dev/null | grep -qi "$proc" ;;
    *) pgrep -x "$proc" >/dev/null 2>&1 || pgrep -f "$proc" >/dev/null 2>&1 ;;
  esac
}

__printf_color() {
  local color="${2:-0}"
  printf "\033[0;%sm%s\033[0m\n" "$color" "$1"
}
__printf_red() { __printf_color "$1" "31"; }
__printf_green() { __printf_color "$1" "32"; }
__printf_yellow() { __printf_color "$1" "33"; }
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Smart notifications
__notifications() {
  local title="$1" msg="$2"

  # Remote/no display - just print to stderr
  if __is_remote || ! __has_display; then
    printf "[%s] %s\n" "$title" "$msg" >&2
    return 0
  fi

  # GUI notifications based on OS
  case "$(__get_os)" in
    mac)
      osascript -e "display notification \"$msg\" with title \"$title\"" 2>/dev/null && return 0
      ;;
    linux|bsd)
      if __cmd_exists notify-send; then
        notify-send "$title" "$msg" 2>/dev/null && return 0
      fi
      ;;
    windows)
      if __cmd_exists powershell.exe; then
        powershell.exe -Command "Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.MessageBox]::Show('$msg', '$title')" 2>/dev/null && return 0
      fi
      ;;
  esac

  # Fallback
  printf "[%s] %s\n" "$title" "$msg" >&2
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Version and help
__version() { echo "$PROG $VERSION"; }

__help() {
  cat <<EOF
$PROG $VERSION - Static and live bonsai tree generator

Usage: $PROG [options]

Options:
  -l, --live             Enable live generation
  -t, --time TIME        Time between each step of growth [default: 0.01]
  -m, --message TEXT     Attach a message to the tree
  -b, --basetype 0-2     Which ascii-art plant base to use (0 for none) [default: 1]
  -i, --infinite         Keep generating trees until quit (2s between each)
  -T, --termcolors       Use terminal colors
  -g, --geo X,Y          Set custom geometry [default: fit to terminal]
  -c, --leaf CHAR        Character used for leaves [default: &]
  -M, --multiplier 0-9   Branch multiplier; higher equals more branching [default: 5]
  -L, --life INT         Life of tree; higher equals more overall growth [default: 28]
  -v, --version          Show version
  -h, --help             Show this help

Examples:
  $PROG -l                      # Live generation
  $PROG -m "Hello World"        # With message
  $PROG -i                      # Infinite mode
EOF
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Main function
main() {
  local exitCode=0

  # Parse options first
  case "${1:-}" in
    -v|--version) __version; exit 0 ;;
    -h|--help) __help; exit 0 ;;
  esac

  # Check for required applications
  if ! __cmd_exists bash; then
    __printf_red "Error: bash is required"
    exit 1
  fi

  # Defaults
  local live=false
  local infinite=false
  local termCols=$(tput cols)
  local termRows=$(tput lines)
  local geometry="$((termCols - 1)),$termRows"
  local leafchar='&'
  local termColors=false
  local message=""
  local flag_m=false
  local basetype=1
  local multiplier=5
  local lifeStart=28
  local steptime=0.01
  local lineWidth=4

  # Parse all options
  while [ $# -gt 0 ]; do
    case "$1" in
      -l|--live)
        live=true
        shift
        ;;
      -t|--time)
        steptime="$2"
        shift 2
        ;;
      -i|--infinite)
        infinite=true
        shift
        ;;
      -g|--geo)
        geometry="$2"
        shift 2
        ;;
      -c|--leaf)
        leafchar="$2"
        shift 2
        ;;
      -T|--termcolors)
        termColors=true
        shift
        ;;
      -m|--message)
        flag_m=true
        message="$2"
        shift 2
        ;;
      -b|--basetype)
        basetype="$2"
        shift 2
        ;;
      -M|--multiplier)
        multiplier="$2"
        shift 2
        ;;
      -L|--life)
        lifeStart="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        shift
        ;;
    esac
  done

  # geometry processing
  local cols=$(echo "$geometry" | cut -d ',' -f1)
  local rows=$(echo "$geometry" | cut -d ',' -f2)

  IFS=$'\n'
  tabs 4

  declare -A gridMessage

  # message processing
  if [ $flag_m = true ]; then
    local messageWidth=20
    cols=$((cols - messageWidth - 8))
    message="$(echo "$message" | fold -sw $messageWidth)"
    local messageLineCount=0
    for line in $message; do
      messageLineCount=$((messageLineCount + 1))
    done
    local messageOffset=$((rows - messageLineCount - 7))
    local index=$messageOffset
    for line in $message; do
      gridMessage[$index]="$line"
      index=$((index + 1))
    done
  fi

  # define colors
  if [ $termColors = true ]; then
    LightBrown='\e[1;33m'
    DarkBrown='\e[0;33m'
    BrownGreen='\e[1;32m'
    Green='\e[0;32m'
  else
    LightBrown='\e[38;5;172m'
    DarkBrown='\e[38;5;130m'
    BrownGreen='\e[38;5;142m'
    Green='\e[38;5;106m'
  fi
  Grey='\e[1;30m'
  R='\e[0m'

  # create ascii base in lines
  local base=""
  local art=""
  local width=0
  case $basetype in
  0)
    base=""
    ;;
  1)
    width=15
    art="\
${Grey}:${Green}___________${DarkBrown}./~~\\.${Green}___________${Grey}:
 \\                          /
  \\________________________/
  (_)                    (_)"
    ;;
  2)
    width=7
    art="\
${Grey}(${Green}---${DarkBrown}./~~\\.${Green}---${Grey})
 (          )
  (________)"
    ;;
  esac

  # get base height
  local baseHeight=0
  for line in $art; do
    baseHeight=$((baseHeight + 1))
  done

  # add spaces before base
  local iter=1
  for line in $art; do
    local filler=''
    for ((i = 0; i < $(((cols / 2) - width)); i++)); do
      filler+=" "
    done
    base+="${filler}${line}"
    [ $iter -ne $baseHeight ] && base+='\n'
    iter=$((iter + 1))
  done
  unset IFS

  rows=$((rows - baseHeight))

  declare -A grid

  trap 'echo "press q to quit"' SIGINT

  init() {
    branches=0
    shoots=0
    branchesMax=$((multiplier * 110))
    shootsMax=$multiplier

    for ((row = 0; row < $rows; row++)); do
      for ((col = 0; col < $cols; col++)); do
        grid[$row, $col]=' '
      done
    done

    if [ $live = true ]; then
      stty -echo
      echo -ne "\e[?25l"
      echo -ne "\e[2J"
    fi
  }

  grow() {
    local start=$((cols / 2))
    local x=$((cols / 2))
    local y=$rows
    branch $x $y trunk $lifeStart
  }

  branch() {
    local x=$1
    local y=$2
    local type=$3
    local life=$4
    local dx=0
    local dy=0

    local timeout=0.001
    [ $live = "false" ] && timeout=.0001
    read -n 1 -t $timeout input
    [ "$input" = "q" ] && clean "quit"

    branches=$((branches + 1))

    while [ $life -gt 0 ]; do
      life=$((life - 1))

      case $type in
      shoot*)
        case "$((RANDOM % 10))" in
        [0-1]) dy=-1 ;;
        [2-7]) dy=0 ;;
        [8-9]) dy=1 ;;
        esac
        ;;
      dying)
        case "$((RANDOM % 10))" in
        [0-1]) dy=-1 ;;
        [2-8]) dy=0 ;;
        [9-10]) dy=1 ;;
        esac
        ;;
      *)
        dy=0
        [ $life -ne $lifeStart ] && [ $((RANDOM % 10)) -gt 2 ] && dy=-1
        ;;
      esac

      [ $dy -gt 0 ] && [ $y -gt $((rows - 1)) ] && dy=0
      [ $type = "trunk" ] && [ $life -lt 4 ] && dy=0

      case $type in
      shootLeft)
        case $((RANDOM % 10)) in
        [0-1]) dx=-2 ;;
        [2-5]) dx=-1 ;;
        [6-8]) dx=0 ;;
        [9]) dx=1 ;;
        esac ;;
      shootRight)
        case $((RANDOM % 10)) in
        [0-1]) dx=2 ;;
        [2-5]) dx=1 ;;
        [6-8]) dx=0 ;;
        [9]) dx=-1 ;;
        esac ;;
      dying)
        dx=$(((RANDOM % 7) - 3)) ;;
      *)
        dx=$(((RANDOM % 3) - 1)) ;;
      esac

      if [ $branches -lt $branchesMax ]; then
        if [ $life -lt 3 ]; then
          branch $x $y dead $life
        elif [ $type = trunk ] && [ $life -lt $((multiplier + 2)) ]; then
          branch $x $y dying $life
        elif [[ $type = "shoot"* ]] && [ $life -lt $((multiplier + 2)) ]; then
          branch $x $y dying $life
        elif [[ $type = trunk && $life -lt $((lifeStart - 8)) && (
          $((RANDOM % (16 - multiplier))) -eq 0 || (
          $type = trunk && $((life % 5)) -eq 0 && $life -gt 5)) ]]; then
          if [ $((RANDOM % 3)) -eq 0 ] && [ $life -gt 7 ]; then
            branch $x $y trunk $life
          elif [ $shoots -lt $shootsMax ]; then
            local tmpLife=$((life + multiplier - 2))
            [ $tmpLife -lt 0 ] && tmpLife=0
            if [ $shoots -eq 0 ]; then
              tmpType=shootLeft
              [ $((RANDOM % 2)) -eq 0 ] && tmpType=shootRight
            else
              case $tmpType in
              shootLeft) tmpType=shootRight ;;
              shootRight) tmpType=shootLeft ;;
              esac
            fi
            branch $x $y $tmpType $tmpLife
            shoots=$((shoots + 1))
          fi
        fi
      else
        char='<>'
      fi

      x=$((x + dx))
      y=$((y + dy))

      case $type in
      trunk | shoot*)
        color=${DarkBrown}
        [ $((RANDOM % 4)) -eq 0 ] && color=${LightBrown}
        ;;
      dying) color=${BrownGreen} ;;
      dead) color=${Green} ;;
      esac

      case $type in
      trunk)
        if [ $dx -lt 0 ]; then
          char='\\'
        elif [ $dx -eq 0 ]; then
          char='/|'
        elif [ $dx -gt 0 ]; then
          char='/'
        fi
        [ $dy -eq 0 ] && char='/~'
        ;;
      shootLeft)
        case $dx in
        [-3,-1]) char='\\|' ;;
        [0]) char='/|' ;;
        [1,3]) char='/' ;;
        esac
        [ $dy -gt 0 ] && char='/'
        [ $dy -eq 0 ] && char='\\_'
        ;;
      shootRight)
        case $dx in
        [-3,-1]) char='\\|' ;;
        [0]) char='/|' ;;
        [1,3]) char='/' ;;
        esac
        [ $dy -gt 0 ] && char='\\'
        [ $dy -eq 0 ] && char='_/'
        ;;
      esac

      [ $life -lt 4 ] && char="${leafchar}"

      grid[$y, $x]="${color}${char}${R}"

      if [ $live = true ]; then
        print
        sleep $steptime
      fi
    done
  }

  print() {
    local output=""
    for ((row = 0; row < $rows; row++)); do
      local line=""
      for ((col = 0; col < $cols; col++)); do
        [ $live = true ] && echo -ne "\e[0;0H "
        line+="${grid[$row, $col]}"
      done
      if [ $flag_m = true ]; then
        line=$(sed -r 's/[ \t]*$//' <(printf "$line"))
        line+="   \t${gridMessage[$row]}"
      fi
      line="${line}\n"
      output+="$line"
    done
    output+="$base"
    sed -r 's/[ \t]*$//' <(printf "$output")
  }

  clean() {
    if [ $live = true ]; then
      echo -ne "\e[?25h"
      stty echo
    fi
    echo ""
    if [ "$1" = "quit" ]; then
      trap SIGINT
      exit 0
    fi
  }

  bonsai() {
    init
    grow
    print
    clean
  }

  bonsai

  while [ $infinite = true ]; do
    sleep 2
    bonsai
  done

  return "${exitCode:-$?}"
}
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Execute
main "$@"
exit $?
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# end
